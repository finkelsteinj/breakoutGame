<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Breakout Game</title>
		<style type="text/css">
			canvas {
        background: #000000;
        outline: white 5px solid;
      }
      body { background-color: #303030; }
      div { color: white; }
		</style>
  </head>

  <body onload="startGame()">

    <script type="text/javascript">

      // TODO: add padding
      // TODO: add score feature
      // TODO: add start / end screen
      // TODO: add styling / animations

    var x = 50,
        y = 250,
        dx = 2,
        dy = 2,
        canvasWidth = 800,
        canvasHeight = 600
        paddleWidth = 150,
        paddleHeight = 10,
        paddleX = (canvasWidth - paddleWidth) / 2,
        paddleY = canvasHeight - paddleHeight - 5,
        brickWidth = (canvasWidth - 10) / 13,
        brickHeight = 15,
        brickX = 5,
        brickY = 50,
        brickCol = 12,
        brickRow = 6,
        lives = 3,
        gameSpeed = 5;

    var bricksArr = [];
    for (var c = 0; c < brickCol; c++) {
      // creates a new empty array in 'bricks[]' at position 'c'
      bricksArr[c] = [];
      for (var r = 0; r < brickRow; r++) {
        // creates a new brick, in 'brick[c]' at postion 'r'
        bricksArr[c][r] = { x: 0, y: 0, status: 1};
      }
    }


    function startGame() {
      gameArea.start();
      ball = new ballComponent(x, y, 10, "#0892d0");
      paddle = new paddleComponent(paddleX,
                                    paddleY,
                                    paddleWidth,
                                    paddleHeight,
                                    "gray");
      bricks = new brickComponents(brickX,
                                    brickY,
                                    brickWidth,
                                    brickHeight,
                                    "#0892d0");
      features = new gameFeatures();
    }

    var gameArea = {
      canvas : document.createElement("canvas"),
      start  : function() {
        this.canvas.width = canvasWidth;
        this.canvas.height = canvasHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]); // ??
        this.interval = setInterval(updateGameArea, gameSpeed);

        // keyboard movement - 37 is left arrow - 39 is right arrow
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            gameArea.keys = (gameArea.keys || []);
            gameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
            gameArea.keys[e.keyCode] = (e.type == "keydown");
        })
      },
      clear  : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }


      // creates paddle object
      function paddleComponent(x, y, width, height, color) {
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;

        this.update = function() {
          ctx = gameArea.context;
          ctx.fillStyle = color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        // checks if the ball collides between the x and y pos of the paddle
        this.checkCollisionWithPaddle = function() {
          if (ball.y >= this.y &&
              ball.y <= this.y + this.height &&
              ball.x >= this.x - ball.radius &&
              ball.x <= this.x + this.width - ball.radius) {
                  return true;
                  console.log('ball-paddle collision')
          } else {
            return false;
          }
        }

        this.bounceOffPaddle = function() {
          if (paddle.checkCollisionWithPaddle() === true) {

            // if ball collides w/ left side of paddle, ball goes left
            if (ball.x + ball.radius <= this.x + (this.width / 2)) {
              dx = -(Math.abs(dx));
              console.log('ball collides w/ left side of paddle')

             // if ball collides w/ right side of paddle, ball goes right
           } else if (ball.x + ball.radius > this.x + (this.width / 2)) {
              dx = Math.abs(dx);
               console.log('ball collides w/ right side of paddle')
            }

            dy = -dy;
          }
        }

        // blocks paddle from going too far left or right of canvas
        this.keepPaddleInGameArea = function() {
          if (this.x <= 0)
            this.x = 0;

          if (this.x + this.width >= canvasWidth)
            this.x = canvasWidth - this.width;
        }
      }


      // creates ball object
      function ballComponent(x, y, radius, color) {
        this.radius = radius;
        this.diameter = radius * 2;
        this.x = x;
        this.y = y;

        this.update = function() {
          ctx = gameArea.context;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.closePath();
        }

        this.hitSideWalls = function() {
          if (this.x + dx < this.radius ||
                this.x + dx > canvasWidth - this.radius)
            dx = -dx;
        }

        this.hitTopWall = function() {
          if (this.y + dy < this.radius)
  					dy = -dy;
        }

        this.hitFloor = function() {
          if (this.y + dy > canvasWidth - this.radius) {
            console.log('Out of Bounds')

            // reset ball position
            this.x = x;
            this.y = y;
            this.dx = Math.abs(dx);
            this.dy = Math.abs(dy);

            lives = lives - 1;
          }
        }
      }


      //creates brick components
      function brickComponents(x, y, width, height, color) {
        this.x = x;
        this. y = y;
        this.width = width;
        this.height = height;

        this.update = function() {
          for (var c = 0; c < brickCol; c++) {
            for (var r = 0; r < brickRow; r++) {
              if (bricksArr[c][r].status == 1) {
                this.x = (c * (this.width + 5)) + 7;
                this.y = (r * (this.height + 5)) + 50;

                bricksArr[c][r].x = this.x;
                bricksArr[c][r].y = this.y;

                ctx = gameArea.context;
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
              }
            }
          }
        }

        this.brickCollision = function() {
          for (c = 0; c < brickCol; c++) {
            for (r = 0; r < brickRow; r++) {
              var b = bricksArr[c][r];

              if (b.status == 1) {
                if (ball.x > b.x - ball.diameter
                    && ball.x < (b.x + this.width) - ball.diameter
                    && ball.y > b.y - ball.diameter
                    && ball.y < (b.y + this.height) - ball.diameter) {
                      dy = -dy;
                      b.status = 0;
                }
              }
            }
          }
        }
      }

      function gameFeatures() {
        this.updateScore = function() {
          if (lives > 0) {
            var score = document.getElementById('score');
            var scoreNumber = score.innerHTML;
            scoreNumber++;
            score.innerHTML = scoreNumber;
          }
        }

        this.checkLives = function() {
          if (lives <= 0) {
            gameArea.clear();

            ctx = gameArea.context;
            ctx.font = "100px Arial";
            ctx.fillStyle = "red";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER", canvasWidth / 2, canvasHeight / 2);
          }
        }
      }


      // runs functions every interval
      function updateGameArea() {
        gameArea.clear();
        if (gameArea.keys && gameArea.keys[37]) { paddle.x -= 3; }
        if (gameArea.keys && gameArea.keys[39]) { paddle.x += 3; }
        ball.x += dx;
        ball.y += dy;
        ball.update();
        ball.hitSideWalls();
        ball.hitTopWall();
        ball.hitFloor();
        paddle.update();
        paddle.bounceOffPaddle();
        paddle.keepPaddleInGameArea();
        bricks.update();
        bricks.brickCollision();
        features.updateScore();
        features.checkLives();
      }

    </script>

    <div>
      <h2>Score:</h2><p id="score">0</p>
    </div>

    <div>
      <h3>Controls:</h3>
      <p>Left arrow to move the paddle left.</br>
        Right arrow to move the paddle right.
      </p>

      <h3>Other Info:</h3>
      <p>If you would like to see the code click
        <a href="https://github.com/finkelsteinj/breakoutGame/blob/master/Breakout.html"
          target="_blank">here</a>!</br>
        If you encounter any bugs, please write them down on the sheet.</br>
      </p>
    </div>

  </body>

</html>
