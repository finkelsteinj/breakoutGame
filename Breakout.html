<!DOCTYPE html>
<html>

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Breakout Game</title>
		<style type="text/css">
			canvas { background: #eee; }
		</style>
  </head>

  <body onload="startGame()">

    <script type="text/javascript">

      // TODO: implement brick collisin dectection
      // TODO: add padding
      // TODO: add score feature
      // TODO: add start / end screen
      // TODO: add styling / animations

    var ball,
        paddle;

    var x = 50,
        y = 250,
        dx = 2,
        dy = 2,
        canvasWidth = 800,
        canvasHeight = 600
        paddleWidth = 150,
        paddleHeight = 10,
        paddleX = (canvasWidth - paddleWidth) / 2,
        paddleY = canvasHeight - paddleHeight - 5,
        brickWidth = (canvasWidth - 10) / 13,
        brickHeight = 15,
        brickX = 5,
        brickY = 50,
        brickCol = 12,
        brickRow = 6;

    var bricksArr = [];
    for (var c = 0; c < brickCol; c++) {
      // creates a new empty array in 'bricks[]' at position 'c'
      bricksArr[c] = [];
      for (var r = 0; r < brickRow; r++) {
        // creates a new brick, in 'brick[c]' at postion 'r'
        bricksArr[c][r] = { x: 0, y: 0 };
      }
    }


    function startGame() {
      gameArea.start();
      ball = new ballComponent(x, y, 10, "blue");
      paddle = new paddleComponent(paddleX,
                                    paddleY,
                                    paddleWidth,
                                    paddleHeight,
                                    "blue");
      bricks = new brickComponents(brickX,
                                    brickY,
                                    brickWidth,
                                    brickHeight,
                                    "blue");
    }

    var gameArea = {
      canvas : document.createElement("canvas"),
      start  : function() {
        this.canvas.width = canvasWidth;
        this.canvas.height = canvasHeight;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]); // ??
        // this.interval = requestAnimationFrame(updateGameArea);
        this.interval = setInterval(updateGameArea, 5);

        // keyboard movement - 37 is left arrow - 39 is right arrow
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            gameArea.keys = (gameArea.keys || []);
            gameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
            gameArea.keys[e.keyCode] = (e.type == "keydown");
        })
      },
      clear  : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }


      // creates paddle object
      function paddleComponent(x, y, width, height, color) {
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;

        this.update = function() {
          ctx = gameArea.context;
          ctx.fillStyle = color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }

        // checks if the ball collides between the x and y pos of the paddle
        this.checkCollisionWithPaddle = function() {
          if (ball.y >= this.y &&
              ball.y <= this.y + this.height &&
              ball.x >= this.x - ball.diameter &&
              ball.x <= this.x + this.width - ball.diameter) {
                  return true;
                  console.log('ball-paddle collision')
          } else {
            return false;
          }
        }

        this.bounceOffPaddle = function() {
          if (paddle.checkCollisionWithPaddle() === true) {

            // if ball collides w/ left side of paddle, ball goes left
            if (ball.x + ball.diameter <= this.x + (this.width / 2)) {
              dx = -(Math.abs(dx));
              console.log('ball collides w/ left side of paddle')

             // if ball collides w/ right side of paddle, ball goes right
            } else if (ball.x + ball.diameter > this.x + (this.width / 2)) {
              dx = Math.abs(dx);
               console.log('ball collides w/ right side of paddle')
            }

            dy = -dy;
          }
        }

        // blocks paddle from going too far left or right of canvas
        this.keepPaddleInGameArea = function() {
          if (this.x <= 0)
            this.x = 0;

          if (this.x + this.width >= canvasWidth)
            this.x = canvasWidth - this.width;
        }
      }


      // creates ball object
      function ballComponent(x, y, radius, color) {
        this.radius = radius;
        this.diameter = radius * 2;
        this.x = x;
        this.y = y;

        this.update = function() {
          ctx = gameArea.context;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.closePath();
        }

        this.hitSideWalls = function() {
          if (this.x + dx < this.radius ||
                this.x + dx > canvasWidth - this.radius)
            dx = -dx;
        }

        this.hitTopWall = function() {
          if (this.y + dy < this.radius)
  					dy = -dy;
        }

        this.hitFloor = function() {
          if (this.y + dy > canvasWidth - this.radius) {
            console.log('Out of Bounds')

            // reset ball position
            this.x = x;
            this.y = y;
            this.dx = Math.abs(dx);
            this.dy = Math.abs(dy);
          }
        }
      }


      //creates brick components
      function brickComponents(x, y, width, height, color) {
        this.x = x;
        this. y = y;
        this.width = width;
        this.height = height;

        this.update = function() {
          for (var c = 0; c < brickCol; c++) {
            for (var r = 0; r < brickRow; r++) {
              this.x = (c * (this.width + 5)) + 7;
              this.y = (r * (this.height + 5)) + 50;

              bricksArr[c][r].x = this.x;
              bricksArr[c][r].y = this.y;

              ctx = gameArea.context;
              ctx.fillStyle = color;
              ctx.fillRect(this.x, this.y, this.width, this.height);
            }
          }
        }

        this.brickCollision = function() {
          // use splice() to remove array elements
        }
      }


      // runs functions every interval
      function updateGameArea() {
        gameArea.clear();
        if (gameArea.keys && gameArea.keys[37]) { paddle.x -= 3; }
        if (gameArea.keys && gameArea.keys[39]) { paddle.x += 3; }
        ball.x += dx;
        ball.y += dy;
        ball.update();
        ball.hitSideWalls();
        ball.hitTopWall();
        ball.hitFloor();
        paddle.update();
        paddle.bounceOffPaddle();
        paddle.keepPaddleInGameArea();
        bricks.update();
        bricks.brickCollision();
      }

    </script>

  </body>

</html>
